{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "e294bd3c-b6f9-4441-8404-97a3b934c372",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "METABRIC columns: ['patient_id', 'age_at_diagnosis', 'type_of_breast_surgery', 'cancer_type', 'cancer_type_detailed', 'cellularity', 'chemotherapy', 'pam50_+_claudin-low_subtype', 'cohort', 'er_status_measured_by_ihc', 'er_status', 'neoplasm_histologic_grade', 'her2_status_measured_by_snp6', 'her2_status', 'tumor_other_histologic_subtype', 'hormone_therapy', 'inferred_menopausal_state', 'integrative_cluster', 'primary_tumor_laterality', 'lymph_nodes_examined_positive', 'mutation_count', 'nottingham_prognostic_index', 'oncotree_code', 'overall_survival_months', 'overall_survival', 'pr_status', 'radio_therapy', '3-gene_classifier_subtype', 'tumor_size', 'tumor_stage', 'death_from_cancer', 'brca1', 'brca2', 'palb2', 'pten', 'tp53', 'atm', 'cdh1', 'chek2', 'nbn', 'nf1', 'stk11', 'bard1', 'mlh1', 'msh2', 'msh6', 'pms2', 'epcam', 'rad51c', 'rad51d', 'rad50', 'rb1', 'rbl1', 'rbl2', 'ccna1', 'ccnb1', 'cdk1', 'ccne1', 'cdk2', 'cdc25a', 'ccnd1', 'cdk4', 'cdk6', 'ccnd2', 'cdkn2a', 'cdkn2b', 'myc', 'cdkn1a', 'cdkn1b', 'e2f1', 'e2f2', 'e2f3', 'e2f4', 'e2f5', 'e2f6', 'e2f7', 'e2f8', 'src', 'jak1', 'jak2', 'stat1', 'stat2', 'stat3', 'stat5a', 'stat5b', 'mdm2', 'tp53bp1', 'adam10', 'adam17', 'aph1a', 'aph1b', 'arrdc1', 'cir1', 'ctbp1', 'ctbp2', 'cul1', 'dll1', 'dll3', 'dll4', 'dtx1', 'dtx2', 'dtx3', 'dtx4', 'ep300', 'fbxw7', 'hdac1', 'hdac2', 'hes1', 'hes5', 'heyl', 'itch', 'jag1', 'jag2', 'kdm5a', 'lfng', 'maml1', 'maml2', 'maml3', 'ncor2', 'ncstn', 'notch1', 'notch2', 'notch3', 'nrarp', 'numb', 'numbl', 'psen1', 'psen2', 'psenen', 'rbpj', 'rbpjl', 'rfng', 'snw1', 'spen', 'hes2', 'hes4', 'hes7', 'hey1', 'hey2', 'acvr1', 'acvr1b', 'acvr1c', 'acvr2a', 'acvr2b', 'acvrl1', 'akt1', 'akt1s1', 'akt2', 'apaf1', 'arl11', 'atr', 'aurka', 'bad', 'bcl2', 'bcl2l1', 'bmp10', 'bmp15', 'bmp2', 'bmp3', 'bmp4', 'bmp5', 'bmp6', 'bmp7', 'bmpr1a', 'bmpr1b', 'bmpr2', 'braf', 'casp10', 'casp3', 'casp6', 'casp7', 'casp8', 'casp9', 'chek1', 'csf1', 'csf1r', 'cxcl8', 'cxcr1', 'cxcr2', 'dab2', 'diras3', 'dlec1', 'dph1', 'egfr', 'eif4e', 'eif4ebp1', 'eif5a2', 'erbb2', 'erbb3', 'erbb4', 'fas', 'fgf1', 'fgfr1', 'folr1', 'folr2', 'folr3', 'foxo1', 'foxo3', 'gdf11', 'gdf2', 'gsk3b', 'hif1a', 'hla-g', 'hras', 'igf1', 'igf1r', 'inha', 'inhba', 'inhbc', 'itgav', 'itgb3', 'izumo1r', 'kdr', 'kit', 'kras', 'map2k1', 'map2k2', 'map2k3', 'map2k4', 'map2k5', 'map3k1', 'map3k3', 'map3k4', 'map3k5', 'mapk1', 'mapk12', 'mapk14', 'mapk3', 'mapk4', 'mapk6', 'mapk7', 'mapk8', 'mapk9', 'mdc1', 'mlst8', 'mmp1', 'mmp10', 'mmp11', 'mmp12', 'mmp13', 'mmp14', 'mmp15', 'mmp16', 'mmp17', 'mmp19', 'mmp2', 'mmp21', 'mmp23b', 'mmp24', 'mmp25', 'mmp26', 'mmp27', 'mmp28', 'mmp3', 'mmp7', 'mmp9', 'mtor', 'nfkb1', 'nfkb2', 'opcml', 'pdgfa', 'pdgfb', 'pdgfra', 'pdgfrb', 'pdpk1', 'peg3', 'pik3ca', 'pik3r1', 'pik3r2', 'plagl1', 'ptk2', 'rab25', 'rad51', 'raf1', 'rassf1', 'rheb', 'rictor', 'rps6', 'rps6ka1', 'rps6ka2', 'rps6kb1', 'rps6kb2', 'rptor', 'slc19a1', 'smad1', 'smad2', 'smad3', 'smad4', 'smad5', 'smad6', 'smad7', 'smad9', 'sptbn1', 'terc', 'tert', 'tgfb1', 'tgfb2', 'tgfb3', 'tgfbr1', 'tgfbr2', 'tgfbr3', 'tsc1', 'tsc2', 'vegfa', 'vegfb', 'wfdc2', 'wwox', 'zfyve9', 'arid1a', 'arid1b', 'cbfb', 'gata3', 'kmt2c', 'kmt2d', 'myh9', 'ncor1', 'pde4dip', 'ptprd', 'ros1', 'runx1', 'tbx3', 'abcb1', 'abcb11', 'abcc1', 'abcc10', 'bbc3', 'bmf', 'cyp2c8', 'cyp3a4', 'fgf2', 'fn1', 'map2', 'map4', 'mapt', 'nr1i2', 'slco1b3', 'tubb1', 'tubb4a', 'tubb4b', 'twist1', 'adgra2', 'afdn', 'aff2', 'agmo', 'agtr2', 'ahnak', 'ahnak2', 'akap9', 'alk', 'apc', 'arid2', 'arid5b', 'asxl1', 'asxl2', 'bap1', 'bcas3', 'birc6', 'cacna2d3', 'ccnd3', 'chd1', 'clk3', 'clrn2', 'col12a1', 'col22a1', 'col6a3', 'ctcf', 'ctnna1', 'ctnna3', 'dnah11', 'dnah2', 'dnah5', 'dtwd2', 'fam20c', 'fanca', 'fancd2', 'flt3', 'foxp1', 'frmd3', 'gh1', 'gldc', 'gpr32', 'gps2', 'hdac9', 'herc2', 'hist1h2bc', 'kdm3a', 'kdm6a', 'klrg1', 'l1cam', 'lama2', 'lamb3', 'large1', 'ldlrap1', 'lifr', 'lipi', 'magea8', 'map3k10', 'map3k13', 'men1', 'mtap', 'muc16', 'myo1a', 'myo3a', 'ncoa3', 'nek1', 'nf2', 'npnt', 'nr2f1', 'nr3c1', 'nras', 'nrg3', 'nt5e', 'or6a2', 'palld', 'pbrm1', 'ppp2cb', 'ppp2r2a', 'prkacg', 'prkce', 'prkcq', 'prkcz', 'prkg1', 'prps2', 'prr16', 'ptpn22', 'ptprm', 'rasgef1b', 'rpgr', 'ryr2', 'sbno1', 'setd1a', 'setd2', 'setdb1', 'sf3b1', 'sgcd', 'shank2', 'siah1', 'sik1', 'sik2', 'smarcb1', 'smarcc1', 'smarcc2', 'smarcd1', 'spaca1', 'stab2', 'stmn2', 'syne1', 'taf1', 'taf4b', 'tbl1xr1', 'tg', 'thada', 'thsd7a', 'ttyh1', 'ubr5', 'ush2a', 'usp9x', 'utrn', 'zfp36l1', 'ackr3', 'akr1c1', 'akr1c2', 'akr1c3', 'akr1c4', 'akt3', 'ar', 'bche', 'cdk8', 'cdkn2c', 'cyb5a', 'cyp11a1', 'cyp11b2', 'cyp17a1', 'cyp19a1', 'cyp21a2', 'cyp3a43', 'cyp3a5', 'cyp3a7', 'ddc', 'hes6', 'hsd17b1', 'hsd17b10', 'hsd17b11', 'hsd17b12', 'hsd17b13', 'hsd17b14', 'hsd17b2', 'hsd17b3', 'hsd17b4', 'hsd17b6', 'hsd17b7', 'hsd17b8', 'hsd3b1', 'hsd3b2', 'hsd3b7', 'mecom', 'met', 'ncoa2', 'nrip1', 'pik3r3', 'prkci', 'prkd1', 'ran', 'rdh5', 'sdc4', 'serpini1', 'shbg', 'slc29a1', 'sox9', 'spry2', 'srd5a1', 'srd5a2', 'srd5a3', 'st7', 'star', 'tnk2', 'tulp4', 'ugt2b15', 'ugt2b17', 'ugt2b7', 'pik3ca_mut', 'tp53_mut', 'muc16_mut', 'ahnak2_mut', 'kmt2c_mut', 'syne1_mut', 'gata3_mut', 'map3k1_mut', 'ahnak_mut', 'dnah11_mut', 'cdh1_mut', 'dnah2_mut', 'kmt2d_mut', 'ush2a_mut', 'ryr2_mut', 'dnah5_mut', 'herc2_mut', 'pde4dip_mut', 'akap9_mut', 'tg_mut', 'birc6_mut', 'utrn_mut', 'tbx3_mut', 'col6a3_mut', 'arid1a_mut', 'lama2_mut', 'notch1_mut', 'cbfb_mut', 'ncor2_mut', 'col12a1_mut', 'col22a1_mut', 'pten_mut', 'akt1_mut', 'atr_mut', 'thada_mut', 'ncor1_mut', 'stab2_mut', 'myh9_mut', 'runx1_mut', 'nf1_mut', 'map2k4_mut', 'ros1_mut', 'lamb3_mut', 'arid1b_mut', 'erbb2_mut', 'sf3b1_mut', 'shank2_mut', 'ep300_mut', 'ptprd_mut', 'usp9x_mut', 'setd2_mut', 'setd1a_mut', 'thsd7a_mut', 'afdn_mut', 'erbb3_mut', 'rb1_mut', 'myo1a_mut', 'alk_mut', 'fanca_mut', 'adgra2_mut', 'ubr5_mut', 'pik3r1_mut', 'myo3a_mut', 'asxl2_mut', 'apc_mut', 'ctcf_mut', 'asxl1_mut', 'fancd2_mut', 'taf1_mut', 'kdm6a_mut', 'ctnna3_mut', 'brca1_mut', 'ptprm_mut', 'foxo3_mut', 'usp28_mut', 'gldc_mut', 'brca2_mut', 'cacna2d3_mut', 'arid2_mut', 'aff2_mut', 'lifr_mut', 'sbno1_mut', 'kdm3a_mut', 'ncoa3_mut', 'bap1_mut', 'l1cam_mut', 'pbrm1_mut', 'chd1_mut', 'jak1_mut', 'setdb1_mut', 'fam20c_mut', 'arid5b_mut', 'egfr_mut', 'map3k10_mut', 'smarcc2_mut', 'erbb4_mut', 'npnt_mut', 'nek1_mut', 'agmo_mut', 'zfp36l1_mut', 'smad4_mut', 'sik1_mut', 'casp8_mut', 'prkcq_mut', 'smarcc1_mut', 'palld_mut', 'dcaf4l2_mut', 'bcas3_mut', 'cdkn1b_mut', 'gps2_mut', 'men1_mut', 'stk11_mut', 'sik2_mut', 'ptpn22_mut', 'brip1_mut', 'flt3_mut', 'nrg3_mut', 'fbxw7_mut', 'ttyh1_mut', 'taf4b_mut', 'or6a2_mut', 'map3k13_mut', 'hdac9_mut', 'prkacg_mut', 'rpgr_mut', 'large1_mut', 'foxp1_mut', 'clk3_mut', 'prkcz_mut', 'lipi_mut', 'ppp2r2a_mut', 'prkce_mut', 'gh1_mut', 'gpr32_mut', 'kras_mut', 'nf2_mut', 'chek2_mut', 'ldlrap1_mut', 'clrn2_mut', 'acvrl1_mut', 'agtr2_mut', 'cdkn2a_mut', 'ctnna1_mut', 'magea8_mut', 'prr16_mut', 'dtwd2_mut', 'akt2_mut', 'braf_mut', 'foxo1_mut', 'nt5e_mut', 'ccnd3_mut', 'nr3c1_mut', 'prkg1_mut', 'tbl1xr1_mut', 'frmd3_mut', 'smad2_mut', 'sgcd_mut', 'spaca1_mut', 'rasgef1b_mut', 'hist1h2bc_mut', 'nr2f1_mut', 'klrg1_mut', 'mbl2_mut', 'mtap_mut', 'ppp2cb_mut', 'smarcd1_mut', 'nras_mut', 'ndfip1_mut', 'hras_mut', 'prps2_mut', 'smarcb1_mut', 'stmn2_mut', 'siah1_mut']\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "C:\\Users\\vetdd\\AppData\\Local\\Temp\\ipykernel_22192\\4152196741.py:4: DtypeWarning: Columns (678,688,690,692) have mixed types. Specify dtype option on import or set low_memory=False.\n",
      "  df_metabric = pd.read_csv(\"../data/METABRIC_RNA_Mutation.csv\")\n"
     ]
    }
   ],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "\n",
    "df_metabric = pd.read_csv(\"../data/METABRIC_RNA_Mutation.csv\")\n",
    "print(\"METABRIC columns:\", df_metabric.columns.tolist())\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "c3010654-6195-4d6c-bea0-b1e074de9fcb",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "   patient_id  age_at_diagnosis type_of_breast_surgery    cancer_type  \\\n",
      "0           0             75.65             MASTECTOMY  Breast Cancer   \n",
      "1           2             43.19      BREAST CONSERVING  Breast Cancer   \n",
      "\n",
      "               cancer_type_detailed cellularity  chemotherapy  \\\n",
      "0  Breast Invasive Ductal Carcinoma         NaN             0   \n",
      "1  Breast Invasive Ductal Carcinoma        High             0   \n",
      "\n",
      "  pam50_+_claudin-low_subtype  cohort er_status_measured_by_ihc  ... mtap_mut  \\\n",
      "0                 claudin-low     1.0                   Positve  ...        0   \n",
      "1                        LumA     1.0                   Positve  ...        0   \n",
      "\n",
      "   ppp2cb_mut smarcd1_mut nras_mut ndfip1_mut  hras_mut prps2_mut smarcb1_mut  \\\n",
      "0           0           0        0          0         0         0           0   \n",
      "1           0           0        0          0         0         0           0   \n",
      "\n",
      "  stmn2_mut  siah1_mut  \n",
      "0         0          0  \n",
      "1         0          0  \n",
      "\n",
      "[2 rows x 693 columns]\n"
     ]
    }
   ],
   "source": [
    "print(df_metabric.head(2))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "33550f2c-55d3-4201-a4bb-960f7e09b1a7",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "C:\\Users\\vetdd\\AppData\\Local\\Temp\\ipykernel_22192\\2322447037.py:21: DtypeWarning: Columns (678,688,690,692) have mixed types. Specify dtype option on import or set low_memory=False.\n",
      "  df_metabric = pd.read_csv(metabric_path)\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "METABRIC raw shape: (1904, 693)\n"
     ]
    },
    {
     "ename": "ValueError",
     "evalue": "Target column 'risk_label' not found in METABRIC data.",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mValueError\u001b[0m                                Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[3], line 35\u001b[0m\n\u001b[0;32m     33\u001b[0m target_col_metabric \u001b[38;5;241m=\u001b[39m \u001b[38;5;124m'\u001b[39m\u001b[38;5;124mrisk_label\u001b[39m\u001b[38;5;124m'\u001b[39m\n\u001b[0;32m     34\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m target_col_metabric \u001b[38;5;129;01mnot\u001b[39;00m \u001b[38;5;129;01min\u001b[39;00m df_metabric\u001b[38;5;241m.\u001b[39mcolumns:\n\u001b[1;32m---> 35\u001b[0m     \u001b[38;5;28;01mraise\u001b[39;00m \u001b[38;5;167;01mValueError\u001b[39;00m(\u001b[38;5;124mf\u001b[39m\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mTarget column \u001b[39m\u001b[38;5;124m'\u001b[39m\u001b[38;5;132;01m{\u001b[39;00mtarget_col_metabric\u001b[38;5;132;01m}\u001b[39;00m\u001b[38;5;124m'\u001b[39m\u001b[38;5;124m not found in METABRIC data.\u001b[39m\u001b[38;5;124m\"\u001b[39m)\n\u001b[0;32m     37\u001b[0m \u001b[38;5;66;03m# Drop patient_id from features\u001b[39;00m\n\u001b[0;32m     38\u001b[0m df_metabric \u001b[38;5;241m=\u001b[39m df_metabric\u001b[38;5;241m.\u001b[39mset_index(\u001b[38;5;124m'\u001b[39m\u001b[38;5;124mpatient_id\u001b[39m\u001b[38;5;124m'\u001b[39m)\n",
      "\u001b[1;31mValueError\u001b[0m: Target column 'risk_label' not found in METABRIC data."
     ]
    }
   ],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "from sklearn.model_selection import train_test_split\n",
    "from sklearn.metrics import roc_auc_score, accuracy_score, classification_report\n",
    "from sklearn.preprocessing import LabelEncoder\n",
    "import xgboost as xgb\n",
    "import joblib\n",
    "\n",
    "# File paths\n",
    "metabric_path = \"../data/METABRIC_RNA_Mutation.csv\"\n",
    "bcsc_paths = [\n",
    "    \"bcsc_risk_factors_summarized1_092020.csv\",\n",
    "    \"bcsc_risk_factors_summarized2_092020.csv\",\n",
    "    \"bcsc_risk_factors_summarized3_092020.csv\"\n",
    "]\n",
    "\n",
    "# -----------------------------------------\n",
    "# 1. Process METABRIC RNA dataset\n",
    "# -----------------------------------------\n",
    "# Load METABRIC data\n",
    "df_metabric = pd.read_csv(metabric_path)\n",
    "print(\"METABRIC raw shape:\", df_metabric.shape)\n",
    "\n",
    "# Identify patient ID and target column (e.g., 'risk_label' or 'outcome')\n",
    "# Replace 'risk_label' with your actual target column name\n",
    "if 'patient_id' not in df_metabric.columns:\n",
    "    if 'PATIENT_ID' in df_metabric.columns:\n",
    "        df_metabric = df_metabric.rename(columns={'PATIENT_ID': 'patient_id'})\n",
    "    else:\n",
    "        df_metabric = df_metabric.rename(columns={df_metabric.columns[0]: 'patient_id'})\n",
    "\n",
    "# Example: assume target column is named 'risk_label'\n",
    "target_col_metabric = 'risk_label'\n",
    "if target_col_metabric not in df_metabric.columns:\n",
    "    raise ValueError(f\"Target column '{target_col_metabric}' not found in METABRIC data.\")\n",
    "\n",
    "# Drop patient_id from features\n",
    "df_metabric = df_metabric.set_index('patient_id')\n",
    "\n",
    "def clean_metabric(df):\n",
    "    # Separate features and target\n",
    "    X = df.drop(columns=[target_col_metabric])\n",
    "    y = df[target_col_metabric]\n",
    "\n",
    "    # Fill missing values: numeric → median, categorical → mode\n",
    "    for col in X.columns:\n",
    "        if X[col].isnull().any():\n",
    "            if X[col].dtype in [np.float64, np.int64]:\n",
    "                X[col] = X[col].fillna(X[col].median())\n",
    "            else:\n",
    "                mode = X[col].mode()\n",
    "                X[col] = X[col].fillna(mode[0] if len(mode)>0 else 'Unknown')\n",
    "\n",
    "    # Encode categorical variables\n",
    "    encoders = {}\n",
    "    for col in X.select_dtypes(include=['object', 'category']).columns:\n",
    "        le = LabelEncoder()\n",
    "        X[col] = le.fit_transform(X[col].astype(str))\n",
    "        encoders[col] = le\n",
    "\n",
    "    # Encode target if categorical\n",
    "    if y.dtype == 'object' or str(y.dtype).startswith('category'):\n",
    "        y_le = LabelEncoder()\n",
    "        y = y_le.fit_transform(y.astype(str))\n",
    "    else:\n",
    "        y_le = None\n",
    "\n",
    "    return X, y, encoders, y_le\n",
    "\n",
    "X_metabric, y_metabric, metabric_feature_encoders, metabric_target_encoder = clean_metabric(df_metabric)\n",
    "print(\"METABRIC features shape:\", X_metabric.shape)\n",
    "\n",
    "# Train-test split\n",
    "X_train_m, X_test_m, y_train_m, y_test_m = train_test_split(\n",
    "    X_metabric, y_metabric, test_size=0.2, random_state=42, stratify=y_metabric\n",
    ")\n",
    "\n",
    "# XGBoost classifier\n",
    "model_metabric = xgb.XGBClassifier(\n",
    "    n_estimators=100,\n",
    "    max_depth=6,\n",
    "    learning_rate=0.1,\n",
    "    subsample=0.8,\n",
    "    colsample_bytree=0.8,\n",
    "    use_label_encoder=False,\n",
    "    eval_metric='logloss',\n",
    "    random_state=42\n",
    ")\n",
    "\n",
    "model_metabric.fit(X_train_m, y_train_m)\n",
    "\n",
    "# Evaluate METABRIC model\n",
    "y_pred_m = model_metabric.predict(X_test_m)\n",
    "try:\n",
    "    y_pred_prob_m = model_metabric.predict_proba(X_test_m)[:, 1]\n",
    "    auc_m = roc_auc_score(y_test_m, y_pred_prob_m)\n",
    "    print(f\"METABRIC AUC: {auc_m:.4f}\")\n",
    "except Exception:\n",
    "    auc_m = None\n",
    "print(\"METABRIC Classification Report:\")\n",
    "print(classification_report(y_test_m, y_pred_m))\n",
    "\n",
    "# Save METABRIC model and encoders\n",
    "joblib.dump(model_metabric, \"xgb_model_metabric.pkl\")\n",
    "joblib.dump(metabric_feature_encoders, \"metabric_feature_encoders.pkl\")\n",
    "if metabric_target_encoder:\n",
    "    joblib.dump(metabric_target_encoder, \"metabric_target_encoder.pkl\")\n",
    "\n",
    "# -----------------------------------------\n",
    "# 2. Process BCSC Risk-Factor datasets\n",
    "# -----------------------------------------\n",
    "# Load and concatenate BCSC files\n",
    "df_bcsc_list = []\n",
    "for path in bcsc_paths:\n",
    "    df = pd.read_csv(path)\n",
    "    df_bcsc_list.append(df)\n",
    "    print(f\"Loaded {path} with shape {df.shape}\")\n",
    "\n",
    "df_bcsc = pd.concat(df_bcsc_list, ignore_index=True)\n",
    "print(\"BCSC concatenated shape:\", df_bcsc.shape)\n",
    "\n",
    "# Identify patient_id and target column (e.g., 'risk_label' or 'outcome')\n",
    "if 'patient_id' not in df_bcsc.columns:\n",
    "    if 'PatientID' in df_bcsc.columns:\n",
    "        df_bcsc = df_bcsc.rename(columns={'PatientID': 'patient_id'})\n",
    "    else:\n",
    "        df_bcsc = df_bcsc.rename(columns={df_bcsc.columns[0]: 'patient_id'})\n",
    "\n",
    "# Example: assume target column is 'risk_label'\n",
    "target_col_bcsc = 'risk_label'\n",
    "if target_col_bcsc not in df_bcsc.columns:\n",
    "    raise ValueError(f\"Target column '{target_col_bcsc}' not found in BCSC data.\")\n",
    "\n",
    "# Drop duplicates and set index\n",
    "df_bcsc = df_bcsc.drop_duplicates(subset=['patient_id']).set_index('patient_id')\n",
    "\n",
    "# Clean BCSC data using similar function\n",
    "def clean_bcsc(df):\n",
    "    X = df.drop(columns=[target_col_bcsc])\n",
    "    y = df[target_col_bcsc]\n",
    "\n",
    "    # Fill missing values\n",
    "    for col in X.columns:\n",
    "        if X[col].isnull().any():\n",
    "            if X[col].dtype in [np.float64, np.int64]:\n",
    "                X[col] = X[col].fillna(X[col].median())\n",
    "            else:\n",
    "                mode = X[col].mode()\n",
    "                X[col] = X[col].fillna(mode[0] if len(mode)>0 else 'Unknown')\n",
    "\n",
    "    # Encode categorical variables\n",
    "    encoders = {}\n",
    "    for col in X.select_dtypes(include=['object', 'category']).columns:\n",
    "        le = LabelEncoder()\n",
    "        X[col] = le.fit_transform(X[col].astype(str))\n",
    "        encoders[col] = le\n",
    "\n",
    "    # Encode target\n",
    "    if y.dtype == 'object' or str(y.dtype).startswith('category'):\n",
    "        y_le = LabelEncoder()\n",
    "        y = y_le.fit_transform(y.astype(str))\n",
    "    else:\n",
    "        y_le = None\n",
    "\n",
    "    return X, y, encoders, y_le\n",
    "\n",
    "X_bcsc, y_bcsc, bcsc_feature_encoders, bcsc_target_encoder = clean_bcsc(df_bcsc)\n",
    "print(\"BCSC features shape:\", X_bcsc.shape)\n",
    "\n",
    "# Train-test split for BCSC\n",
    "dimensions = y_bcsc.value_counts().shape[0]\n",
    "stratify_param = y_bcsc if dimensions > 1 else None\n",
    "X_train_b, X_test_b, y_train_b, y_test_b = train_test_split(\n",
    "    X_bcsc, y_bcsc, test_size=0.2, random_state=42, stratify=stratify_param\n",
    ")\n",
    "\n",
    "# XGBoost classifier for BCSC\n",
    "model_bcsc = xgb.XGBClassifier(\n",
    "    n_estimators=100,\n",
    "    max_depth=5,\n",
    "    learning_rate=0.1,\n",
    "    subsample=0.8,\n",
    "    colsample_bytree=0.8,\n",
    "    use_label_encoder=False,\n",
    "    eval_metric='logloss',\n",
    "    random_state=42\n",
    ")\n",
    "\n",
    "model_bcsc.fit(X_train_b, y_train_b)\n",
    "\n",
    "# Evaluate BCSC model\n",
    "y_pred_b = model_bcsc.predict(X_test_b)\n",
    "try:\n",
    "    y_pred_prob_b = model_bcsc.predict_proba(X_test_b)[:, 1]\n",
    "    auc_b = roc_auc_score(y_test_b, y_pred_prob_b)\n",
    "    print(f\"BCSC AUC: {auc_b:.4f}\")\n",
    "except Exception:\n",
    "    auc_b = None\n",
    "print(\"BCSC Classification Report:\")\n",
    "print(classification_report(y_test_b, y_pred_b))\n",
    "\n",
    "# Save BCSC model and encoders\n",
    "joblib.dump(model_bcsc, \"xgb_model_bcsc.pkl\")\n",
    "joblib.dump(bcsc_feature_encoders, \"bcsc_feature_encoders.pkl\")\n",
    "if bcsc_target_encoder:\n",
    "    joblib.dump(bcsc_target_encoder, \"bcsc_target_encoder.pkl\")\n",
    "\n",
    "# -----------------------------------------\n",
    "# 3. Prediction Functions\n",
    "# -----------------------------------------\n",
    "def predict_metabric(new_data_df):\n",
    "    # new_data_df should include same features used in training (no patient_id, no target)\n",
    "    # Fill and encode using saved encoders\n",
    "    X_new = new_data_df.copy()\n",
    "    for col, le in metabric_feature_encoders.items():\n",
    "        X_new[col] = le.transform(X_new[col].astype(str))\n",
    "    # Fill missing if any\n",
    "    for col in X_new.columns:\n",
    "        if X_new[col].isnull().any():\n",
    "            if X_new[col].dtype in [np.float64, np.int64]:\n",
    "                X_new[col] = X_new[col].fillna(X_new[col].median())\n",
    "            else:\n",
    "                mode = X_new[col].mode()\n",
    "                X_new[col] = X_new[col].fillna(mode[0] if len(mode)>0 else 'Unknown')\n",
    "    preds = model_metabric.predict(X_new)\n",
    "    if metabric_target_encoder:\n",
    "        preds = metabric_target_encoder.inverse_transform(preds)\n",
    "    return preds\n",
    "\n",
    "\n",
    "def predict_bcsc(new_data_df):\n",
    "    X_new = new_data_df.copy()\n",
    "    for col, le in bcsc_feature_encoders.items():\n",
    "        X_new[col] = le.transform(X_new[col].astype(str))\n",
    "    for col in X_new.columns:\n",
    "        if X_new[col].isnull().any():\n",
    "            if X_new[col].dtype in [np.float64, np.int64]:\n",
    "                X_new[col] = X_new[col].fillna(X_new[col].median())\n",
    "            else:\n",
    "                mode = X_new[col].mode()\n",
    "                X_new[col] = X_new[col].fillna(mode[0] if len(mode)>0 else 'Unknown')\n",
    "    preds = model_bcsc.predict(X_new)\n",
    "    if bcsc_target_encoder:\n",
    "        preds = bcsc_target_encoder.inverse_transform(preds)\n",
    "    return preds\n",
    "\n",
    "# Example usage:\n",
    "# new_metabric_sample = pd.DataFrame([{ ... }])\n",
    "# print(predict_metabric(new_metabric_sample))\n",
    "# new_bcsc_sample = pd.DataFrame([{ ... }])\n",
    "# print(predict_bcsc(new_bcsc_sample))\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "52fb8dc7-290e-43b5-bfbb-c989011a6579",
   "metadata": {},
   "outputs": [],
   "source": [
    "import streamlit as st\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import joblib\n",
    "import xgboost as xgb\n",
    "\n",
    "# -----------------------------------------\n",
    "# Load Models and Encoders\n",
    "# -----------------------------------------\n",
    "@st.cache_resource\n",
    "def load_models():\n",
    "    # Load METABRIC model and encoders\n",
    "    try:\n",
    "        model_metabric = joblib.load(\"xgb_model_metabric.pkl\")\n",
    "        metabric_feature_encoders = joblib.load(\"metabric_feature_encoders.pkl\")\n",
    "        metabric_target_encoder = None\n",
    "        try:\n",
    "            metabric_target_encoder = joblib.load(\"metabric_target_encoder.pkl\")\n",
    "        except Exception:\n",
    "            pass\n",
    "    except FileNotFoundError:\n",
    "        model_metabric = None\n",
    "        metabric_feature_encoders = {}\n",
    "        metabric_target_encoder = None\n",
    "\n",
    "    # Load BCSC model and encoders\n",
    "    try:\n",
    "        model_bcsc = joblib.load(\"xgb_model_bcsc.pkl\")\n",
    "        bcsc_feature_encoders = joblib.load(\"bcsc_feature_encoders.pkl\")\n",
    "        bcsc_target_encoder = None\n",
    "        try:\n",
    "            bcsc_target_encoder = joblib.load(\"bcsc_target_encoder.pkl\")\n",
    "        except Exception:\n",
    "            pass\n",
    "    except FileNotFoundError:\n",
    "        model_bcsc = None\n",
    "        bcsc_feature_encoders = {}\n",
    "        bcsc_target_encoder = None\n",
    "\n",
    "    return (model_metabric, metabric_feature_encoders, metabric_target_encoder,\n",
    "            model_bcsc, bcsc_feature_encoders, bcsc_target_encoder)\n",
    "\n",
    "model_metabric, metabric_feature_encoders, metabric_target_encoder, \\\n",
    "model_bcsc, bcsc_feature_encoders, bcsc_target_encoder = load_models()\n",
    "\n",
    "# -----------------------------------------\n",
    "# Utility Functions\n",
    "# -----------------------------------------\n",
    "def clean_and_encode_input(input_data: pd.DataFrame, feature_encoders: dict):\n",
    "    df = input_data.copy()\n",
    "    # Fill missing numeric with median, categorical with mode\n",
    "    for col in df.columns:\n",
    "        if df[col].isnull().any():\n",
    "            if df[col].dtype in [np.float64, np.int64, \"float64\", \"int64\"]:\n",
    "                df[col] = df[col].fillna(df[col].median())\n",
    "            else:\n",
    "                mode = df[col].mode()\n",
    "                df[col] = df[col].fillna(mode[0] if len(mode)>0 else 'Unknown')\n",
    "    # Encode categorical columns using provided encoders\n",
    "    for col, le in feature_encoders.items():\n",
    "        if col in df.columns:\n",
    "            df[col] = le.transform(df[col].astype(str))\n",
    "    return df\n",
    "\n",
    "# -----------------------------------------\n",
    "# Streamlit App Layout\n",
    "# -----------------------------------------\n",
    "st.set_page_config(page_title=\"Breast Cancer Risk Predictor\", layout=\"wide\")\n",
    "st.title(\"Breast Cancer Risk Prediction Website\")\n",
    "\n",
    "dataset_choice = st.sidebar.radio(\"Select Model:\", (\"BCSC Risk Model\", \"METABRIC Risk Model\"))\n",
    "\n",
    "if dataset_choice == \"BCSC Risk Model\":\n",
    "    st.header(\"Risk Prediction Based on Clinical Risk Factors\")\n",
    "    if model_bcsc is None:\n",
    "        st.error(\"BCSC model not found. Please ensure 'xgb_model_bcsc.pkl' and encoders are available.\")\n",
    "    else:\n",
    "        # Retrieve feature names\n",
    "        feature_names = model_bcsc.get_booster().feature_names\n",
    "        user_inputs = {}\n",
    "        st.subheader(\"Enter Your Clinical Risk Factors:\")\n",
    "        # Create form for inputs\n",
    "        with st.form(key='bcsc_form'):\n",
    "            for feature in feature_names:\n",
    "                if feature in bcsc_feature_encoders:\n",
    "                    # Categorical: use selectbox with encoder classes_\n",
    "                    classes = bcsc_feature_encoders[feature].classes_\n",
    "                    user_inputs[feature] = st.selectbox(f\"{feature}\", classes)\n",
    "                else:\n",
    "                    # Numeric: number_input\n",
    "                    user_inputs[feature] = st.number_input(f\"{feature}\", value=0.0)\n",
    "            submitted = st.form_submit_button(\"Predict Risk\")\n",
    "        if submitted:\n",
    "            input_df = pd.DataFrame([user_inputs])\n",
    "            X_new = clean_and_encode_input(input_df, bcsc_feature_encoders)\n",
    "            # Ensure column order\n",
    "            X_new = X_new[feature_names]\n",
    "            # Predict\n",
    "            proba = model_bcsc.predict_proba(X_new)[0]\n",
    "            pred_class_idx = np.argmax(proba)\n",
    "            pred_label = pred_class_idx\n",
    "            if bcsc_target_encoder:\n",
    "                pred_label = bcsc_target_encoder.inverse_transform([pred_class_idx])[0]\n",
    "            st.success(f\"Predicted Risk Category: {pred_label}\")\n",
    "            st.subheader(\"Risk Probabilities:\")\n",
    "            risk_df = pd.DataFrame({\n",
    "                'Category': bcsc_target_encoder.classes_ if bcsc_target_encoder else [str(i) for i in range(len(proba))],\n",
    "                'Probability': proba\n",
    "            })\n",
    "            st.bar_chart(data=risk_df.set_index('Category'))\n",
    "\n",
    "            # Risk Management Recommendations\n",
    "            st.subheader(\"Risk Management Recommendations\")\n",
    "            recommendations = {\n",
    "                'Low': \"Maintain a healthy lifestyle: regular exercise, balanced diet, and routine screenings.\",\n",
    "                'Intermediate': \"Consult with your healthcare provider about preventive strategies such as lifestyle modifications and possible chemoprevention.\",\n",
    "                'High': \"Seek genetic counseling and discuss risk-reducing options, including enhanced surveillance, medications, or surgical interventions.\"\n",
    "            }\n",
    "            rec = recommendations.get(pred_label, \"Please consult your healthcare provider for personalized advice.\")\n",
    "            st.write(rec)\n",
    "\n",
    "            # Support Resources\n",
    "            st.subheader(\"Supportive Resources\")\n",
    "            st.markdown(\"- [Grant Application Assistance](https://www.bcfoundation.org/grants)\")\n",
    "            st.markdown(\"- [Local Support Groups](https://www.breastcancer.org/support/local-groups)\")\n",
    "            st.markdown(\"- [Educational Video: Self-Care Tips](https://www.youtube.com/watch?v=example)\")\n",
    "\n",
    "elif dataset_choice == \"METABRIC Risk Model\":\n",
    "    st.header(\"Risk Prediction Based on RNA Mutation Data\")\n",
    "    if model_metabric is None:\n",
    "        st.error(\"METABRIC model not found. Please ensure 'xgb_model_metabric.pkl' and encoders are available.\")\n",
    "    else:\n",
    "        feature_names = model_metabric.get_booster().feature_names\n",
    "        user_inputs = {}\n",
    "        st.subheader(\"Enter Your RNA Mutation Features:\")\n",
    "        with st.form(key='metabric_form'):\n",
    "            for feature in feature_names:\n",
    "                if feature in metabric_feature_encoders:\n",
    "                    classes = metabric_feature_encoders[feature].classes_\n",
    "                    user_inputs[feature] = st.selectbox(f\"{feature}\", classes)\n",
    "                else:\n",
    "                    user_inputs[feature] = st.number_input(f\"{feature}\", value=0.0)\n",
    "            submitted = st.form_submit_button(\"Predict Risk\")\n",
    "        if submitted:\n",
    "            input_df = pd.DataFrame([user_inputs])\n",
    "            X_new = clean_and_encode_input(input_df, metabric_feature_encoders)\n",
    "            X_new = X_new[feature_names]\n",
    "            proba = model_metabric.predict_proba(X_new)[0]\n",
    "            pred_class_idx = np.argmax(proba)\n",
    "            pred_label = pred_class_idx\n",
    "            if metabric_target_encoder:\n",
    "                pred_label = metabric_target_encoder.inverse_transform([pred_class_idx])[0]\n",
    "            st.success(f\"Predicted Risk Category: {pred_label}\")\n",
    "            st.subheader(\"Risk Probabilities:\")\n",
    "            risk_df = pd.DataFrame({\n",
    "                'Category': metabric_target_encoder.classes_ if metabric_target_encoder else [str(i) for i in range(len(proba))],\n",
    "                'Probability': proba\n",
    "            })\n",
    "            st.bar_chart(data=risk_df.set_index('Category'))\n",
    "\n",
    "            st.subheader(\"Risk Management Recommendations\")\n",
    "            recommendations = {\n",
    "                'Low': \"Continue routine monitoring and maintain healthy habits.\",\n",
    "                'Intermediate': \"Discuss targeted surveillance and consider molecular-guided interventions.\",\n",
    "                'High': \"Consult with oncogenomics specialist and explore personalized treatment strategies.\"\n",
    "            }\n",
    "            rec = recommendations.get(pred_label, \"Please consult your healthcare provider for personalized advice.\")\n",
    "            st.write(rec)\n",
    "\n",
    "            st.subheader(\"Supportive Resources\")\n",
    "            st.markdown(\"- [Grant Application Assistance](https://www.bcfoundation.org/grants)\")\n",
    "            st.markdown(\"- [Local Support Groups](https://www.breastcancer.org/support/local-groups)\")\n",
    "            st.markdown(\"- [Educational Video: Self-Care Tips](https://www.youtube.com/watch?v=example)\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b32b6d13-10fd-4488-8be7-3dab34eb336a",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "\n",
    "# 1. Load METABRIC RNA+mutation file (must include clinical follow‑up columns)\n",
    "df = pd.read_csv(\"../data/METABRIC_RNA_Mutation.csv\")\n",
    "\n",
    "# 2. Ensure 'patient_id' is set as index (rename first column if needed)\n",
    "if \"patient_id\" not in df.columns and \"PATIENT_ID\" in df.columns:\n",
    "    df = df.rename(columns={\"PATIENT_ID\": \"patient_id\"})\n",
    "elif \"patient_id\" not in df.columns:\n",
    "    df = df.rename(columns={df.columns[0]: \"patient_id\"})\n",
    "df = df.set_index(\"patient_id\")\n",
    "\n",
    "# 3. Identify/clean the survival time and status columns.\n",
    "#\n",
    "#    In METABRIC, clinical follow‑up fields are often named:\n",
    "#      • disease_specific_survival_months  (numeric)\n",
    "#      • disease_specific_survival_status  (1 = died of disease, 0 = censored/alive)\n",
    "#      • overall_survival_months, overall_survival_status\n",
    "#\n",
    "#    Adjust these names if your CSV differs. First, confirm they exist:\n",
    "required = [\"disease_specific_survival_months\", \"disease_specific_survival_status\"]\n",
    "for col in required:\n",
    "    if col not in df.columns:\n",
    "        raise KeyError(f\"Column '{col}' not found; please verify your METABRIC clinical fields.\")\n",
    "\n",
    "# 4. Choose a survival threshold in months (e.g., 48 for 4 years)\n",
    "threshold_months = 48\n",
    "\n",
    "# 5. Create a new binary column 'risk_label' as follows:\n",
    "#      • risk_label = 0  if survival_months >= threshold OR (death_status == 0 and survival_months < threshold)\n",
    "#      • risk_label = 1  if death_status == 1 and survival_months < threshold\n",
    "#\n",
    "#    In plain terms:\n",
    "#       – “Sensitive” (0) = lived past threshold (or still alive but less follow‑up than threshold)\n",
    "#       – “Resistant” (1) = died of disease before reaching threshold_months\n",
    "#\n",
    "def assign_risk_label(row, months_thr):\n",
    "    surv = row[\"disease_specific_survival_months\"]\n",
    "    status = row[\"disease_specific_survival_status\"]\n",
    "    # Died of breast cancer before threshold → label = 1 (resistant)\n",
    "    if (status == 1) and (surv < months_thr):\n",
    "        return 1\n",
    "    # Otherwise → label = 0 (sensitive or censored after threshold)\n",
    "    return 0\n",
    "\n",
    "df[\"risk_label\"] = df.apply(assign_risk_label, axis=1, months_thr=threshold_months)\n",
    "\n",
    "# 6. Quick sanity check: count how many fall into each category\n",
    "print(\"Risk‐label distribution (0 = sensitive, 1 = resistant):\")\n",
    "print(df[\"risk_label\"].value_counts())\n",
    "\n",
    "# 7. (Optional) Subset to patients who actually received chemotherapy and/or hormone therapy.\n",
    "#    The METABRIC clinical fields include, for example, 'chemotherapy' and 'hormone_therapy':\n",
    "#\n",
    "#    • chemotherapy: 1 = yes, 0 = no\n",
    "#    • hormone_therapy: 1 = yes, 0 = no\n",
    "#\n",
    "#    To mimic the “CT and/or HT” cohort in Mucaki et al., keep any patient with either field = 1:\n",
    "if \"chemotherapy\" in df.columns and \"hormone_therapy\" in df.columns:\n",
    "    df_treated = df[(df[\"chemotherapy\"] == 1) | (df[\"hormone_therapy\"] == 1)]\n",
    "else:\n",
    "    df_treated = df  # if those fields aren’t present, skip filtering\n",
    "\n",
    "print(f\"Total patients in treated cohort: {df_treated.shape[0]}\")\n",
    "\n",
    "# 8. Save a new CSV with the derived risk_label for downstream modeling\n",
    "df_treated.to_csv(\"METABRIC_with_dss_risk_label.csv\")\n",
    "\n",
    "# 9. From here, you can load “METABRIC_with_dss_risk_label.csv” into your XGBoost pipelines\n",
    "#    exactly as before, using risk_label as the target.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "60d8296c-c3a5-42f2-be88-68b877145ac5",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "\n",
    "bcsc_paths = [\n",
    "    \"../data/bcsc_risk_factors_summarized1_092020.csv\",\n",
    "    \"../data/bcsc_risk_factors_summarized2_092020.csv\",\n",
    "    \"../data/bcsc_risk_factors_summarized3_092020.csv\"\n",
    "]\n",
    "\n",
    "df_list = []\n",
    "for path in bcsc_paths:\n",
    "    df = pd.read_csv(path)\n",
    "    print(f\"Loaded {path}, shape: {df.shape}\")\n",
    "    df_list.append(df)\n",
    "\n",
    "bcsc_df = pd.concat(df_list, ignore_index=True)\n",
    "bcsc_df_clean = bcsc_df[bcsc_df['breast_cancer_history'] != 9].reset_index(drop=True)\n",
    "print(f\"DataFrame shape after dropping: {bcsc_df_clean.shape}\")\n",
    "\n",
    "# Count how many rows dropped\n",
    "dropped_count = bcsc_df.shape[0] - bcsc_df_clean.shape[0]\n",
    "print(f\"Dropped rows: {dropped_count}\")\n",
    "\n",
    "# 3. Save cleaned concatenated DataFrame\n",
    "df_clean_path = \"../data/bcsc_concatenated_no_hist9.csv\"\n",
    "bcsc_df_clean.to_csv(df_clean_path, index=False)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "55c67743-6c6c-4485-ae50-fa2e6544d60b",
   "metadata": {},
   "outputs": [],
   "source": [
    "risk_factors = pd.read_csv('../data/bcsc_concatenated_no_hist9.csv')\n",
    "print(risk_factors.head(2))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7696b515-f880-41c5-93dc-f0a69be9f78b",
   "metadata": {},
   "outputs": [],
   "source": [
    "import streamlit as st\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import joblib\n",
    "import xgboost as xgb\n",
    "import os\n",
    "\n",
    "# -----------------------------------------\n",
    "# Inject custom CSS for a professional blue-gray theme\n",
    "# -----------------------------------------\n",
    "custom_css = '''\n",
    "<style>\n",
    "/* Set a light gray background for the main area */\n",
    ".reportview-container, .main .block-container {\n",
    "    background-color: #f5f7fa;\n",
    "}\n",
    "/* Set sidebar background and text color */\n",
    ".sidebar .sidebar-content {\n",
    "    background-color: #2c3e50;\n",
    "    color: #ecf0f1;\n",
    "}\n",
    "/* Style the header text */\n",
    ".stApp h1 {\n",
    "    color: #2c3e50;\n",
    "}\n",
    ".stApp h2, .stApp h3, .stApp h4 {\n",
    "    color: #34495e;\n",
    "}\n",
    "/* Button styling */\n",
    ".stButton > button {\n",
    "    background-color: #2980b9;\n",
    "    color: white;\n",
    "    border-radius: 5px;\n",
    "    padding: 0.5em 1em;\n",
    "}\n",
    "/* Input widget labels */\n",
    ".stLabel {\n",
    "    color: #2c3e50;\n",
    "}\n",
    "</style>\n",
    "'''\n",
    "\n",
    "st.markdown(custom_css, unsafe_allow_html=True)\n",
    "\n",
    "# -----------------------------------------\n",
    "# Load trained XGBoost model and encoders\n",
    "# -----------------------------------------\n",
    "MODEL_PATH = os.path.join(\"..\", \"data\", \"bcsc_xgb_model.pkl\")\n",
    "ENCODERS_PATH = os.path.join(\"..\", \"data\", \"bcsc_feature_encoders.pkl\")\n",
    "TARGET_ENCODER_PATH = os.path.join(\"..\", \"data\", \"bcsc_target_encoder.pkl\")\n",
    "\n",
    "@st.cache_resource\n",
    "def load_model_and_encoders():\n",
    "    if not os.path.exists(MODEL_PATH) or not os.path.exists(ENCODERS_PATH):\n",
    "        return None, None, None\n",
    "    model = joblib.load(MODEL_PATH)\n",
    "    feature_encoders = joblib.load(ENCODERS_PATH)\n",
    "    target_encoder = joblib.load(TARGET_ENCODER_PATH) if os.path.exists(TARGET_ENCODER_PATH) else None\n",
    "    return model, feature_encoders, target_encoder\n",
    "\n",
    "model, feature_encoders, target_encoder = load_model_and_encoders()\n",
    "\n",
    "# If model failed to load, display error and stop\n",
    "if model is None or feature_encoders is None:\n",
    "    st.error(\"Model or encoders not found. Please ensure 'bcsc_xgb_model.pkl' and 'bcsc_feature_encoders.pkl' are placed in '../data/'.\")\n",
    "    st.stop()\n",
    "\n",
    "# -----------------------------------------\n",
    "# Define mapping lists for BCSC covariates\n",
    "# -----------------------------------------\n",
    "age_group_options = [\n",
    "    \"1 = Age 18-29\", \"2 = Age 30-34\", \"3 = Age 35-39\", \"4 = Age 40-44\", \n",
    "    \"5 = Age 45-49\", \"6 = Age 50-54\", \"7 = Age 55-59\", \"8 = Age 60-64\", \n",
    "    \"9 = Age 65-69\", \"10 = Age 70-74\", \"11 = Age 75-79\", \"12 = Age 80-84\", \"13 = Age ≥85\"\n",
    "]\n",
    "race_eth_options = [\n",
    "    \"1 = Non-Hispanic white\", \"2 = Non-Hispanic black\", \"3 = Asian/Pacific Islander\", \n",
    "    \"4 = Native American\", \"5 = Hispanic\", \"6 = Other/mixed\", \"9 = Unknown\"\n",
    "]\n",
    "first_degree_hx_options = [\"0 = No\", \"1 = Yes\", \"9 = Unknown\"]\n",
    "age_menarche_options = [\"0 = Age ≥14\", \"1 = Age 12-13\", \"2 = Age <12\", \"9 = Unknown\"]\n",
    "age_first_birth_options = [\n",
    "    \"0 = Age <20\", \"1 = Age 20-24\", \"2 = Age 25-29\", \"3 = Age ≥30\", \"4 = Nulliparous\", \"9 = Unknown\"\n",
    "]\n",
    "birads_density_options = [\n",
    "    \"1 = Almost entirely fat\", \"2 = Scattered fibroglandular densities\", \n",
    "    \"3 = Heterogeneously dense\", \"4 = Extremely dense\", \"9 = Unknown/different system\"\n",
    "]\n",
    "current_hrt_options = [\"0 = No\", \"1 = Yes\", \"9 = Unknown\"]\n",
    "menopaus_options = [\"1 = Pre- or peri-menopausal\", \"2 = Post-menopausal\", \"3 = Surgical menopause\", \"9 = Unknown\"]\n",
    "bmi_group_options = [\"1 = 10-24.99\", \"2 = 25-29.99\", \"3 = 30-34.99\", \"4 = 35 or more\", \"9 = Unknown\"]\n",
    "biophx_options = [\"0 = No\", \"1 = Yes\", \"9 = Unknown\"]\n",
    "\n",
    "# -----------------------------------------\n",
    "# Streamlit App Layout\n",
    "# -----------------------------------------\n",
    "st.set_page_config(page_title=\"Breast Cancer Risk Predictor\", layout=\"centered\")\n",
    "st.title(\"Breast Cancer Risk Predictor\")\n",
    "st.write(\"Please enter your personal and clinical information below:\")\n",
    "\n",
    "# Sidebar instructions\n",
    "st.sidebar.header(\"Instructions\")\n",
    "st.sidebar.write(\"Select the options matching your profile.\\nOnce complete, click 'Predict Risk'.\")\n",
    "\n",
    "# User inputs using selectboxes with preset codes and labels\n",
    "st.header(\"Patient Covariates\")\n",
    "\n",
    "col1, col2 = st.columns(2)\n",
    "with col1:\n",
    "    age_group_sel = st.selectbox(\"Age Group (5-year)\", age_group_options)\n",
    "    race_sel = st.selectbox(\"Race/Ethnicity\", race_eth_options)\n",
    "    fhx_sel = st.selectbox(\"First-degree Family History of Breast Cancer\", first_degree_hx_options)\n",
    "    menarche_sel = st.selectbox(\"Age at Menarche\", age_menarche_options)\n",
    "    first_birth_sel = st.selectbox(\"Age at First Birth\", age_first_birth_options)\n",
    "\n",
    "with col2:\n",
    "    density_sel = st.selectbox(\"BI-RADS Breast Density\", birads_density_options)\n",
    "    hrt_sel = st.selectbox(\"Use of Hormone Replacement Therapy\", current_hrt_options)\n",
    "    menopaus_sel = st.selectbox(\"Menopausal Status\", menopaus_options)\n",
    "    bmi_sel = st.selectbox(\"BMI Group (kg/m²)\", bmi_group_options)\n",
    "    biophx_sel = st.selectbox(\"Previous Breast Biopsy/Aspiration\", biophx_options)\n",
    "\n",
    "# Function to parse selected option and extract code\n",
    "def parse_code(selection):\n",
    "    try:\n",
    "        return int(selection.split(\"=\")[0].strip())\n",
    "    except:\n",
    "        return np.nan\n",
    "\n",
    "# Gather input values into a DataFrame\n",
    "input_dict = {\n",
    "    'age_group_5_years': parse_code(age_group_sel),\n",
    "    'race_eth': parse_code(race_sel),\n",
    "    'first_degree_hx': parse_code(fhx_sel),\n",
    "    'age_menarche': parse_code(menarche_sel),\n",
    "    'age_first_birth': parse_code(first_birth_sel),\n",
    "    'BIRADS_breast_density': parse_code(density_sel),\n",
    "    'current_hrt': parse_code(hrt_sel),\n",
    "    'menopaus': parse_code(menopaus_sel),\n",
    "    'bmi_group': parse_code(bmi_sel),\n",
    "    'biophx': parse_code(biophx_sel)\n",
    "}\n",
    "\n",
    "input_df = pd.DataFrame([input_dict])\n",
    "\n",
    "# Ensure the input DataFrame has same column order as training data\n",
    "if model is not None:\n",
    "    feature_cols = model.get_booster().feature_names\n",
    "    input_df = input_df[feature_cols]\n",
    "else:\n",
    "    feature_cols = list(input_df.columns)\n",
    "    input_df = input_df[feature_cols]\n",
    "\n",
    "# Handle any missing or NaNs (shouldn't occur with selectboxes)\n",
    "input_df = input_df.fillna(0)\n",
    "\n",
    "# Predict button\n",
    "def predict_risk():\n",
    "    proba = model.predict_proba(input_df)[0]\n",
    "    classes = target_encoder.classes_ if target_encoder else [\"0\", \"1\"]\n",
    "    pred_idx = np.argmax(proba)\n",
    "    pred_label = classes[pred_idx]\n",
    "    return pred_label, proba\n",
    "\n",
    "if st.button(\"Predict Risk\"):\n",
    "    with st.spinner(\"Computing risk...\"):\n",
    "        label, probabilities = predict_risk()\n",
    "    st.subheader(\"Predicted Risk Outcome\")\n",
    "    st.write(f\"**Breast Cancer History (0 = No, 1 = Yes)**: {label}\")\n",
    "\n",
    "    # Display probability bar chart\n",
    "    prob_df = pd.DataFrame({\n",
    "        'Outcome': target_encoder.classes_ if target_encoder else [\"0\", \"1\"],\n",
    "        'Probability': probabilities\n",
    "    }).set_index('Outcome')\n",
    "    st.bar_chart(prob_df)\n",
    "\n",
    "    # Risk management recommendations\n",
    "    st.subheader(\"Risk Management Recommendations\")\n",
    "    if label == '0':\n",
    "        st.write(\"Based on your inputs, you are at lower risk. Continue routine screening and maintain a healthy lifestyle.\")\n",
    "    else:\n",
    "        st.write(\"Based on your inputs, you have elevated risk. Please consult your healthcare provider for personalized recommendations, which may include enhanced surveillance, genetic counseling, and lifestyle modifications.\")\n",
    "\n",
    "    # Supportive resources\n",
    "    st.subheader(\"Supportive Resources\")\n",
    "    st.markdown(\"- [Breast Cancer Foundation Grants](https://www.bcfoundation.org/grants)\")\n",
    "    st.markdown(\"- [Local Support Groups](https://www.breastcancer.org/support/local-groups)\")\n",
    "    st.markdown(\"- [Educational Video on Breast Health](https://www.youtube.com/watch?v=example)\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "75ba1223-2d2f-48a7-92ad-7d9b011df80b",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python [conda env:base] *",
   "language": "python",
   "name": "conda-base-py"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
